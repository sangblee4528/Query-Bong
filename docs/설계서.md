# 📑 01_00.Genesis_Concept.md

## 1. 프로젝트 개요 (Overview)
* **명칭:** Query-Bong (지능형 쿼리 생성기)
* **목적:** 검증된 쿼리 자산을 정규화하여 관리하고, 사용자의 모호한 질문을 시스템의 명확한 의도로 치환하여 안전하고 정확한 SQL을 생성하는 RAG 기반 시스템.

## 2. 탄생 배경 및 필요성 (Background)
현장 엔지니어의 업무 중 상당 부분은 기존에 제공했던 쿼리에서 단순 조건(`WHERE`)만 변경하여 다시 추출하는 반복적 소모 업무임. 특히 정산 업무처럼 미세한 조건 변동이 잦은 영역에서 발생하는 히스토리 관리의 부재와 중복 작업을 해결하기 위해 기획됨.

## 3. 핵심 설계 철학 (Core Philosophies)

### 3.1 업무의 이원화 (Task Tiering)
* **AI (지능형 생성기):** 기존 자산을 활용한 단순 조건 변경 및 정형화된 데이터 추출 담당.
* **인간 (전문 엔지니어):** 로직 설계, 고도화된 복합 분석 등 고부가가치 업무에 집중하여 업무 효율 극대화.

### 3.2 데이터 무결성 강제 (Normalization)
* **Alias-Free:** 모든 쿼리 내 별칭(`A`, `T1` 등)을 제거하고 전체 테이블명(`Full Table Name`)으로 강제 치환.
* **컬럼 소유권 명확화:** 식별되지 않는 컬럼 사용을 원천 차단하여 데이터 정합성 오류와 AI의 환각(Hallucination) 방지.

### 3.3 영역 기반 관점 격리 (Domain Isolation)
* **도메인별 격리:** 정산, 카드, 회원 등 업무 영역별로 테이블을 분리하여 동일 용어의 중의적 의미(예: 매출의 기준 등) 충돌 방지.
* **로직 보호:** 각 업무팀이 가진 고유한 관점과 쿼리에 녹아있는 전문 지식을 영역별 유닛(Grade A/B/C)으로 보호.

### 3.4 상호 확인 프로세스 (Discovery & Guide)
* **질문의 구체화:** 검색창 대신 '메뉴판(Domain List)'을 제시하여 사용자의 모호한 의도를 시스템 규격으로 정렬.
* **되묻기 전략:** 시스템이 이해하지 못하거나 정의되지 않은 범위의 질문이 들어올 경우, 임의 판단을 중단하고 사용자에게 의도를 재확인하여 질문을 정제함.

## 4. 사용자 여정 (User Experience Flow)
1. **의도 노출:** 사용자가 자연어로 질문 시작.
2. **영역 추천:** 시스템이 질문 키워드와 연관된 도메인 영역 제시.
3. **의도 정합성 확인:** 시스템이 이해한 내용이 맞는지 사용자에게 질문 및 가이드 제공.
4. **쿼리 합성:** Alias가 제거된 표준 뼈대에 검증된 `WHERE` 절 조건을 결합하여 결과 도출.

## 5. 자가 진단 및 평가 (Self-Evolution)
운영 로그(`usage_stats.sqlite`)를 통해 템플릿별 매칭 성공률과 인기 쿼리를 분석하고, 성공률이 낮은 영역을 시스템이 스스로 리포트하여 지속적으로 고도화함.

---
*최종 수정일: 2025-12-26*
*프로젝트 파트너: Gemini (시니어 시스템 엔지니어 모드)*# 📂 01_00_Index.md

## 📑 Query-Bong 아이디어 아카이브 맵

이 인덱스는 프로젝트의 기획 단계에서 발생한 모든 철학적 논의와 정의서를 체계적으로 관리하기 위한 문서 지도입니다.

### 1. 마스터 정의서 (The Constitution)
* **[01_00.Genesis_Concept.md](./01_00.Genesis_Concept.md)**: 프로젝트 전체의 핵심 철학과 사용자 여정을 정의한 마스터 기획서.

### 2. 단계별 인터뷰 기록 (Q&A History)
* **[01_01.Project_Genesis_QnA.md](./01_01.Project_Genesis_QnA.md)**: 왜 이 프로젝트가 시작되었는가? (업무 이원화 및 자동화 기획 배경)
* **[01_02.Normalization_Philosophy_QnA.md](./01_02.Normalization_Philosophy_QnA.md)**: 왜 Alias를 제거하는가? (데이터 무결성 및 정규화 철학)
* **[01_03.Domain_and_Unit_Strategy_QnA.md](./01_03.Domain_and_Unit_Strategy_QnA.md)**: 왜 영역을 나누는가? (업무 도메인 격리 및 관점의 보호)
* **[01_04.Discovery_and_Evaluation_QnA.md](./01_04.Discovery_and_Evaluation_QnA.md)**: 왜 시스템이 되묻는가? (모호함의 구체화 및 시스템 자가 평가 전략)

---
*최종 업데이트: 2025-12-26*
*관리자: Query-Bong 프로젝트 리드 (시니어 시스템 엔지니어)*
# 📄 02_01.Technical_Constraint_and_Normalization.md

## 1. 질문 (Question)
**지능형 쿼리 생성기가 처리하는 SQL의 범위를 제한하고, 컬럼의 출처를 명확히 해야 하는 기술적 이유는 무엇입니까?**

## 2. 답변 요약 (Answer Summary)
본 시스템은 안전성을 위해 오직 `SELECT` 구문만을 처리 대상으로 한정한다. 이는 DML 작업으로 인한 데이터 훼손 위험을 방지하기 위함이다. 또한, 테이블과 컬럼의 관계를 명확히 정의하지 않으면 존재하지 않는 컬럼을 참조하는 오류가 발생하므로, 정규화 과정에서 이를 확실히 검증해야 한다.

## 3. 기술적 제약 사항 (Technical Constraints)
* **SELECT 문 전용:** 데이터 조회 및 분석 목적으로만 제한하여 운영 환경의 파괴적 행위를 원천 차단함.
* **Alias 전수 제거:** 파싱 단계에서 모든 별칭을 실제 테이블명으로 치환하여 쿼리의 소유권을 명확히 함.
* **컬럼 존재성 확인:** 조회하려는 컬럼이 해당 테이블에 실제로 존재하는지 메타데이터(JSON)와 대조하여 사전 검증함.

## 4. 구현 로직 (Implementation Logic)
1. **DML 필터링:** 입력된 SQL이 `SELECT`로 시작하지 않을 경우 프로세스 즉시 중단.
2. **별칭 치환:** `A.COL_NAME` 형태를 `TABLE_NAME.COL_NAME`으로 변환.
3. **무결성 체크:** JSON 스키마에 정의되지 않은 컬럼이 포함된 경우 'Unknown Column' 에러 발생 및 리포트 생성.

---
*기록일: 2025-12-26*
*작성자: Query-Bong 프로젝트 팀*
# 📄 01_02.Normalization_Philosophy_QnA.md

## 1. 질문 (Question)
**왜 기존 쿼리를 분석할 때 Alias(별칭)를 완전히 제거하고 전체 테이블명(Full Table Name)으로 치환해야 합니까?**

## 2. 답변 요약 (Answer Summary)
Alias(`A`, `B`, `T1` 등)를 그대로 두면 해당 식별자가 가리키는 실제 테이블이 무엇인지 즉각적으로 파악하기 어렵다. 이는 나중에 테이블에 존재하지 않는 컬럼을 잘못 사용하거나, 컬럼의 출처를 오인하여 데이터 추출 결과에 치명적인 오류를 범하는 원인이 된다.

## 3. 핵심 설계 철학 (Philosophy)
* **식별의 명확성:** `A.user_id`가 아닌 `User_Master.user_id`로 표기함으로써, 쿼리 내 모든 컬럼의 '진짜 주인'을 명확히 한다.
* **오류 방지 (Error Prevention):** 테이블과 컬럼의 연결 고리를 강제로 일치시켜, 해당 테이블에 없는 컬럼을 사용하려는 시도를 원천 차단한다.
* **시스템 확장성:** 여러 도메인(정산, 카드, 회원 등)의 테이블이 복합적으로 Join될 때, 별칭 중복으로 인한 혼선을 방지하고 쿼리 결합의 안전성을 확보한다.

## 4. 예상되는 위험 (Risk Mitigation)
* **컬럼 환각 방지:** 테이블명을 명시하지 않을 경우, AI가 존재하지 않는 컬럼을 임의의 테이블에 소속시켜 쿼리를 생성하는 '환각 현상'을 방지함.
* **디버깅 가시성:** 문제가 발생했을 때 어떤 테이블의 어떤 컬럼에서 데이터 정합성이 깨졌는지 즉시 추적이 가능함.

---
*기록일: 2025-12-26*
*작성자: Query-Bong 프로젝트 팀*
# 📄 01_03.Domain_and_Unit_Strategy_QnA.md

## 1. 질문 (Question)
**테이블 영역(Domain)을 나누고 쿼리를 등급별로 분류한 근본적인 이유는 무엇입니까?**

## 2. 답변 요약 (Answer Summary)
데이터를 요청하는 사용자들은 각자의 담당 업무(Domain)가 있으며, 같은 용어를 사용하더라도 업무 관점에 따라 그 의도가 전혀 다르기 때문이다. 시스템이 영역을 나누지 않으면 용어의 혼선으로 인해 잘못된 로직이 적용될 위험이 크다. 따라서 영역별로 통용되는 개념을 격리하여 관리하고, 기존 자산에 없는 모호한 요청은 반드시 의도를 재확인해야 한다.

## 3. 핵심 설계 의도 (Rationale)
* **관점의 격리 (Context Isolation):** [교통정산], [유통정산] 등 업무 영역별로 서로 다른 비즈니스 로직과 용어의 의미를 독립적으로 유지함.
* **로직의 암시적 반영:** 쿼리에는 이미 해당 업무팀의 전문적인 로직과 개념이 반영되어 있으므로, 영역별 쿼리 유닛(Grade A/B/C)을 통해 이를 체계적으로 자산화함.
* **의도 매칭 (Intent Matching):** 사용자의 질문이 기존에 정의된 영역이나 개념에 존재하지 않을 경우, AI가 임의로 판단하지 않고 사용자에게 의도를 다시 질문하도록 유도하여 오류를 방지함.

## 4. 영역 및 유닛 관리의 가치
* **관리의 효율성:** 모든 업무 개념을 하나로 통합 관리하는 불가능한 목표 대신, 영역별로 최적화된 관리를 실현함.
* **정확한 매칭:** 질문자의 소속과 질문의 맥락을 특정 영역에 매핑함으로써, 가장 적합하고 검증된 쿼리 뼈대(Template)를 찾아낼 확률을 높임.

---
*기록일: 2025-12-26*
*작성자: Query-Bong 프로젝트 팀*
# 📄 01_04.Discovery_and_Evaluation_QnA.md

## 1. 질문 (Question)
**왜 사용자에게 검색창 대신 '메뉴판'을 보여주고, 시스템이 역으로 질문하는 구조를 선택했습니까?**

## 2. 답변 요약 (Answer Summary)
사용자는 본인이 원하는 결과를 정확히 정의하지 못한 채 질문하는 경우가 많으며, 때로는 시스템이 처리할 수 없는 범위를 요구하기도 한다. 따라서 시스템이 사용자의 말을 무조건 수행하기보다, 시스템이 정의한 범위 내에서 올바르게 이해하고 있는지 확인하고 가이드를 주는 '상호 확인' 과정이 필수적이다.

## 3. 핵심 설계 의도 (Rationale)
* **질문의 구체화 (Clarification):** 사용자의 모호한 표현을 시스템이 보유한 도메인(메뉴판)과 대조하여 명확한 선택지로 치환함.
* **범위 밖 요청의 필터링 (Out-of-Scope Handling):** 시스템에서 정의되지 않은 요청이 들어왔을 때, 환각(Hallucination)을 일으키지 않고 "제공할 수 없는 범위"임을 안내하거나 유사한 대안을 제시함.
* **피드백 루프 (Feedback Loop):** 질문-답변의 매칭 결과를 기록하고 분석함으로써, 어떤 템플릿이 사용자 의도를 잘 반영하는지 혹은 어떤 부분이 보완되어야 하는지 시스템이 스스로 평가하고 리포트함.

## 4. 운영 및 평가의 가치
* **성공률 기반 최적화:** 매칭 성공률이 낮은 영역을 파악하여 쿼리 뼈대를 보강하거나 가이드 문구를 수정하는 기초 자료로 활용.
* **사용자 경험(UX) 개선:** 접속자 정보와 자주 쓰는 쿼리 패턴을 분석하여, 유저별로 더 정교한 '맞춤형 메뉴판'을 제공할 수 있는 기반 마련.

---
*기록일: 2025-12-26*
*작성자: Query-Bong 프로젝트 팀*
# 📄 02_00.Technical_Design_Index.md

## 1. 개요 (Overview)
본 문서는 **Query-Bong 프로젝트**의 기술 설계(Phase 02) 단계에서 도출된 표준 정의서 및 알고리즘 설계서의 통합 인덱스이다. 쿼리 분석기(Analyzer) 구현 시 본 인덱스에 명시된 설계 원칙을 최우선으로 준수해야 한다.

## 2. 기술 설계 문서 리스트 (Design Documents)

### [02_01] 기술 제약 및 정규화 원칙
* **[02_01.Technical_Constraint_and_Normalization.md](./02_01.Technical_Constraint_and_Normalization.md)**
    * **핵심 내용:** - `SELECT` 구문 한정 처리로 시스템 안전성 확보.
        - `Alias` 완전 제거 및 `Full Table Name` 치환을 통한 데이터 정합성 확보.
        - 컬럼별 테이블 소유권(Ownership) 전수 검증 로직 정의.

### [02_02] 메타데이터 검증 전략
* **[02_02.Metadata_Verification_Strategy.md](./02_02.Metadata_Verification_Strategy.md)**
    * **핵심 내용:** - DB 시스템 뷰(`all_tab_comments`, `all_col_comments`) 기반 화이트리스트 검증.
        - `OWNER` 정보를 활용한 시스템/사용자 테이블 자동 분류 및 접근 제어.

### [02_03] JSON 데이터 구조 스펙
* **[02_03.JSON_Data_Schema.md](./02_03.JSON_Data_Schema.md)**
    * **핵심 내용:** - 쿼리 자산의 삼원화 관리 체계 구축 (`Fixed`, `Flexible`, `Change`).
        - 분석 대상 쿼리의 청사진(Blueprint) 포맷 및 영역별 식별자 정의.

### [02_04] JSON 데이터 상세 명세 (Dictionary)
* **[02_04.JSON_Data_Schema_detail.md](./02_04.JSON_Data_Schema_detail.md)**
    * **핵심 내용:** - 각 JSON 필드별 엄격한 데이터 타입 및 비즈니스 유효성 규칙 정의.
        - `control_type` 기반 UI 렌더링 가이드 및 `dependency_join` 처리 프로세스.

### [02_05] 쿼리 자동 추출/분류 알고리즘
* **[02_05.Query_Analysis_Algorithm.md](./02_05.Query_Analysis_Algorithm.md)**
    * **핵심 내용:** - `FROM/JOIN` 절(Inline View 포함)의 `Fixed` 영역 최우선 분류 알고리즘.
        - `WHERE` 절 조건의 Active/Addable 속성 자동 추출 및 이원화 로직.

---

## 3. 설계 로드맵 (Roadmap)
* **Phase 01:** 요구사항 분석 (완료)
* **Phase 02:** 기술 설계 및 데이터 규격 확정 (완료)
* **Phase 03:** Analyzer 엔진 및 파이썬 로직 구현 (진행 예정)

---
*최종 업데이트: 2025-12-26*
*작성자: 시니어 시스템 엔지니어 & Query-Bong 팀*
# 📄 02_01.Technical_Constraint_and_Normalization.md

## 1. 질문 (Question)
**지능형 쿼리 생성기가 처리하는 SQL의 범위를 제한하고, 컬럼의 출처를 명확히 해야 하는 기술적 이유는 무엇입니까?**

## 2. 답변 요약 (Answer Summary)
본 시스템은 안전성을 위해 오직 `SELECT` 구문만을 처리 대상으로 한정한다. 이는 DML 작업으로 인한 데이터 훼손 위험을 방지하기 위함이다. 또한, 테이블과 컬럼의 관계를 명확히 정의하지 않으면 존재하지 않는 컬럼을 참조하는 오류가 발생하므로, 정규화 과정에서 이를 확실히 검증해야 한다.

## 3. 기술적 제약 사항 (Technical Constraints)
* **SELECT 문 전용:** 데이터 조회 및 분석 목적으로만 제한하여 운영 환경의 파괴적 행위를 원천 차단함.
* **Alias 전수 제거:** 파싱 단계에서 모든 별칭을 실제 테이블명으로 치환하여 쿼리의 소유권을 명확히 함.
* **컬럼 존재성 확인:** 조회하려는 컬럼이 해당 테이블에 실제로 존재하는지 메타데이터(JSON)와 대조하여 사전 검증함.

## 4. 구현 로직 (Implementation Logic)
1. **DML 필터링:** 입력된 SQL이 `SELECT`로 시작하지 않을 경우 프로세스 즉시 중단.
2. **별칭 치환:** `A.COL_NAME` 형태를 `TABLE_NAME.COL_NAME`으로 변환.
3. **무결성 체크:** JSON 스키마에 정의되지 않은 컬럼이 포함된 경우 'Unknown Column' 에러 발생 및 리포트 생성.

---
*기록일: 2025-12-26*
*작성자: Query-Bong 프로젝트 팀*
# 📄 02_02.Metadata_Verification_Strategy.md

## 1. 질문 (Question)
**지능형 쿼리 생성기가 참조하는 테이블과 컬럼의 정합성 및 소유권 구분을 어떻게 보장합니까?**

## 2. 답변 요약 (Answer Summary)
DB 시스템 뷰인 `all_tab_comments` 및 `all_col_comments`를 데이터 검증의 근거로 사용한다. 해당 뷰에는 `OWNER` 정보가 포함되어 있어, 이를 통해 기본 시스템 테이블과 사용자 정의 테이블을 명확히 구분할 수 있다. 이 메타데이터에 정의된 정보와 이미 실행이 검증된 쿼리 자산만을 결합하여 쿼리를 생성한다.

## 3. 메타데이터 활용 및 식별 전략 (Strategy)
* **소유자 기반 자동 분리:** 시스템 뷰 내의 `OWNER` 컬럼을 활용하여 별도의 추가 관리 없이도 [기본 시스템 테이블]과 [사용자 생성 테이블]을 기술적으로 격리함.
* **화이트리스트 기반 검증:** 쿼리 생성 시, 해당 뷰에 존재하지 않는 테이블이나 컬럼 조합이 발생하면 즉시 오류로 간주하여 실행을 차단함.
* **데이터 사전(Data Dictionary) 동기화:** 쿼리 분석기(Analyzer)가 이 시스템 뷰를 참조하여 쿼리 내의 모든 객체가 실제 DB 환경과 일치하는지 전수 검사함.

## 4. 무결성 보장 프로세스
* **실행 이력 기반 뼈대:** 시스템이 제공하는 기본 쿼리는 이미 실제 환경에서 수행된 이력이 있는 자산으로 한정함.
* **수동 보완 및 승인:** 대규모 로직 변경이나 신규 도메인 추가 시, 엔지니어가 시스템 뷰의 정보와 실제 쿼리 정합성을 검토한 후 자산 리스트에 등록함.

---
*최종 수정일: 2025-12-26*
*작성자: Query-Bong 프로젝트 팀*
# 📄 02_03.JSON_Data_Schema.md

## 1. 질문 (Question)
**복합 업무 영역(Multi-Domain)을 수용하고, 지표 선택의 확장성과 권한에 따른 조건절 제어 기능을 포함하는 최종 JSON 데이터 스펙은 무엇입니까?**

## 2. 답변 요약 (Answer Summary)
쿼리를 구성하는 핵심 컴포넌트를 **삼원화(Fixed, Flexible, Change)**하여 관리한다. 
* **Fixed:** 절대 변하지 않는 쿼리의 핵심 골격.
* **Flexible:** 사용자의 선택에 따라 동적으로 추가되는 지표와 확장 컬럼 (Join 의존성 관리 포함).
* **Change:** 필수 조건과 선택 가능 조건 풀로 이원화하여, 사용자의 권한에 따라 필터의 가변성을 제어한다.
모든 식별자는 Alias를 배제한 **Full Table Name**을 사용하여 데이터 정합성을 보장한다.

## 3. 최종 JSON 데이터 스키마 명세

{
  "unit_identity": {
    "complex_domains": ["TRANS", "SETTLE"],
    "grade": "A",
    "intent": "교통 수단별 정산 내역 분석",
    "required_permission_level": "USER"
  },
  "query_blueprint": {
    "fixed_area": {
      "comment": "쿼리의 데이터 소스 - 런타임 시 절대 변경 불가",
      "full_from_clause": "KSCCDW.TB_SETTLE_FACT INNER JOIN USER1.TB_USER_INFO ON KSCCDW.TB_SETTLE_FACT.USER_ID = USER1.TB_USER_INFO.USER_ID"
    },
    "flexible_area": {
      "comment": "SELECT 절과 GROUP BY 절의 쌍(Pair) - 패키지 기반 선택",
      "indicator_packages": [
        {
          "package_id": "PKG_BASIC",
          "name": "기본 지표",
          "description": "정산일자별 기본 금액 합계",
          "select_columns": [
            { "name": "정산일자", "formula": "KSCCDW.TB_SETTLE_FACT.SETTLE_DT" },
            { "name": "총정산금액", "formula": "SUM(KSCCDW.TB_SETTLE_FACT.AMT)" }
          ],
          "group_by_columns": [
            "KSCCDW.TB_SETTLE_FACT.SETTLE_DT"
          ]
        },
        {
          "package_id": "PKG_DETAIL",
          "name": "상세 지표",
          "description": "고객 정보가 포함된 상세 내역",
          "select_columns": [
            { "name": "정산일자", "formula": "KSCCDW.TB_SETTLE_FACT.SETTLE_DT" },
            { "name": "고객명", "formula": "USER1.TB_USER_INFO.USER_NAME" },
            { "name": "총정산금액", "formula": "SUM(KSCCDW.TB_SETTLE_FACT.AMT)" }
          ],
          "group_by_columns": [
            "KSCCDW.TB_SETTLE_FACT.SETTLE_DT",
            "USER1.TB_USER_INFO.USER_NAME"
          ]
        }
      ]
    },
    "change_area": {
      "comment": "조건절 영역 - 권한에 따른 제어 차별화",
      "mandatory_filters": [
        {
          "id": "FLT_DATE",
          "name": "조회기간",
          "target_column": "KSCCDW.TB_SETTLE_FACT.SETTLE_DT",
          "operator": "BETWEEN",
          "control_type": "VALUE_ONLY",
          "is_mandatory": true,
          "default_value": ["20251201", "20251226"]
        }
      ],
      "optional_filter_pool": [
        {
          "id": "FLT_STATION",
          "name": "역명/기관명",
          "target_column": "KSCCDW.TB_SETTLE_FACT.ORG_CD",
          "operator": "IN",
          "control_type": "DYNAMIC_ADD_DELETE",
          "accessible_roles": ["ADMIN", "MANAGER"]
        },
        {
          "id": "FLT_USER_GRADE",
          "name": "사용자 등급",
          "target_column": "USER1.TB_USER_INFO.USER_GRADE",
          "operator": "=",
          "control_type": "DYNAMIC_ADD_DELETE",
          "accessible_roles": ["ADMIN"]
        }
      ]
    }
  }
}
# 📄 02_04.JSON_Data_Schema_detail.md (최종 통합본)

## 1. 질문 (Question)
**지능형 쿼리 생성기의 JSON 스키마를 구성하는 각 필드(Key)의 기술적 의미, 데이터 타입 및 비즈니스 제약 사항은 무엇입니까?**

## 2. 답변 요약 (Answer Summary)
본 문서는 `02_03`에서 정의한 JSON 구조의 상세 명세를 정의한다. 모든 필드는 쿼리의 안정적 생성과 사용자의 권한 기반 제어를 지원하도록 설계되었으며, 특히 **SELECT-GROUP BY의 동적 정합성** 보장과 **`change_area`를 통한 런타임 필터 제어**를 통해 쿼리 오류와 보안 취약점을 사전에 방지한다.

---

## 3. 상세 필드 기술 명세 (Field Dictionary)

### 3.1 unit_identity (개체 식별 및 메타)
| 필드명 | 타입 | 설명 및 비즈니스 규칙 |
| :--- | :--- | :--- |
| `complex_domains` | Array | 쿼리가 참조하는 업무 영역(예: TRANS, SETTLE). Join 범위 결정의 근거. |
| `grade` | String | 쿼리 중요도/난이도 (A: 복합 집계, B: 일반, C: 단순 리스트). |
| `intent` | String | 자연어 매칭을 위한 핵심 목적 요약. LLM이 쿼리 유닛을 매칭하는 기준. |

### 3.2 query_blueprint (쿼리 조립 로직)

#### [fixed_area] : 삭제 불가능한 핵심 골격
* **`tables`**: 쿼리 구동을 위한 최소한의 메인 테이블 리스트. (반드시 Owner를 포함한 Full Name 사용)
* **`base_columns`**: 사용자 선택과 관계없이 항상 포함되는 기본 컬럼 객체 (`formula`, `alias` 포함).
* **`base_group_by`**: 기본 컬럼 중 집계 함수가 아닌 항목에 대한 필수 GROUP BY 리스트.

#### [flexible_area] : 사용자 선택형 지표 및 확장 (SELECT/GROUP BY 쌍 관리)
* **`options`**: UI에서 체크박스로 선택 가능한 지표 패키지.
    * **`add_columns`**: 해당 옵션 선택 시 SELECT 절에 추가될 컬럼 및 계산식.
    * **`add_group_by`**: **(중요)** `add_columns` 중 차원 항목이 추가될 때 반드시 GROUP BY 절에 함께 추가되어야 할 필드.
* **`dependency_join`**: 해당 옵션 선택 시에만 `FROM`절에 동적으로 추가될 조인문.

#### [change_area] : 동적 조건절 및 권한 제어
* **`active_filters`**: 시스템이 강제하는 필수 필터 (예: 기준 일자). `is_mandatory: true` 고정.
* **`addable_filter_pool`**: 사용자가 권한에 따라 추가로 결합할 수 있는 조건 화이트리스트.
* **`column`**: 조건절의 대상이 되는 DB 컬럼명.
* **`operator`**: 해당 필터에서 허용하는 연산자 (`=`, `BETWEEN`, `IN` 등).
* **`control_type`**: 
    - **`VALUE_ONLY`**: 필터 항목 삭제 불가, 입력값(Value)만 수정 가능 (일반 사용자용).
    - **`DYNAMIC_ADD_DELETE`**: 필터 항목 자체를 리스트에서 추가/제거 가능 (관리자급 권한).
* **`is_mandatory`**: `true`일 경우 해당 값이 누락되면 엔진 레벨에서 쿼리 실행을 차단(Fail-safe).

---

## 4. 시스템 엔지니어 가이드 (Implementation Note)

### 4.1 SQL 정합성 (Syntax Integrity)
* 쿼리 빌더는 `base_group_by`와 사용자가 선택한 모든 `options`의 `add_group_by`를 합산(Union)하여 최종 `GROUP BY` 절을 생성해야 한다. 이를 통해 `ORA-00937` 같은 집계 에러를 방지한다.

### 4.2 성능 및 조인 최적화 (Join Optimization)
* `dependency_join`은 중복을 제거하여 쿼리에 포함시킨다. 동일 테이블 조인이 여러 옵션에 걸쳐 있을 경우 `DISTINCT`하게 조립한다.

### 4.3 보안 및 권한 제어 (Security Control)
* `change_area`의 모든 입력값은 SQL Injection 방지를 위해 **Prepared Statement(바인딩 변수)** 처리를 원칙으로 한다.
* `control_type`에 따라 UI 렌더링을 분기하여, 권한이 없는 사용자가 필수 조건을 삭제하지 못하도록 제어한다.

---
*최종 수정일: 2025-12-26*
*작성자: Query-Bong 프로젝트 팀 (Senior SE Review 완료)*# 📄 02_05.Query_Analysis_Algorithm.md

## 1. 질문 (Question)
**쿼리 파서(Query Parser)를 통해 추출된 SQL 구성 요소들을 어떤 순서와 자동화 규칙에 따라 Fixed, Flexible, Change 영역으로 분류합니까?**

## 2. 답변 요약 (Answer Summary)
SQL 표준 실행 순서에 따라 구문을 분석하되, **서브쿼리의 위치에 따른 우선순위**를 적용하여 영역을 자동 배치한다.
1. **SELECT 절:** 모든 항목을 사용자 선택형인 **`Flexible`**로 분류.
2. **FROM/JOIN 절:** 서브쿼리(Inline View)를 포함한 모든 소스를 **`Fixed`**로 분류 (변경 불가 우선순위).
3. **WHERE 절:** **`Change`** 영역으로 분류 (값 변경형/조건 추가형 세분화).
4. **GROUP BY 절:** 데이터 기준 변경을 위한 **`Change`** 영역으로 분류.

## 3. 세부 자동 분류 규칙 (Classification Logic)

### 3.1 SELECT 절 분석 (Flexible Area)
* **판단 기준:** 메인 쿼리의 `SELECT`에 나열된 모든 항목.
* **특징:** 기본/상세/사용자 정의 지표로 전환되는 가변 노출 영역.

### 3.2 FROM / JOIN 절 분석 (Fixed Area - 최우선 순위)
* **판단 기준:** 일반 테이블 및 **FROM 절 내의 서브쿼리(Inline View)**.
* **우선순위 로직:** 서브쿼리가 `FROM` 절에 위치할 경우, 해당 내부 로직은 쿼리의 근간으로 간주하여 전체를 **`Fixed`**로 묶음. 사용자가 내부 조건을 변경할 수 없음.

### 3.3 WHERE 절 분석 (Change Area)
* **내부 분기:**
    * **Active (값 변경형):** 기존 쿼리에 명시된 조건. 값 수정만 허용.
    * **Addable (조건 추가형):** 동적으로 결합 가능한 필터 풀.

### 3.4 GROUP BY 절 분석 (Change Area)
* **판단 기준:** 데이터를 묶는 기준 컬럼들. 집계 단위를 조절하는 제어 요소.

### 3.5 기타 서브쿼리 분석 (Nested Logic)
* **판단 기준:** `SELECT` 절이나 `WHERE` 절 내부에 포함된 서브쿼리(Scalar/Subquery).
* **분류:** 메인 쿼리의 해당 영역 속성을 따르되, 내부 구조를 재귀적으로 파싱하여 변수화 가능 여부를 판단.

---
*최종 수정일: 2025-12-26*
*작성자: Query-Bong 프로젝트 팀*
# 📄 03_00.Implementation_Design_Index.md

## 1. 개요 (Overview)
본 문서는 **Query-Bong 분석기**의 실제 구현을 위한 기술적 메커니즘과 운영 프로세스를 정의한다. 단순 분석을 넘어, 실무 데이터의 이력 관리(Historization)와 추적성(Traceability) 확보를 설계의 핵심 가치로 둔다.

## 2. 구현 설계 문서 리스트 (Implementation Design Documents)

### [03_01] 분석 엔진 기술 스택
* **[03_01.Analyzer_Technology_Stack.md](./03_01.Analyzer_Technology_Stack.md)**
    * **핵심 내용:** - Python 3.10+ 기반 `sqlglot` 라이브러리 채택.
        - AST(추상 구문 트리) 분석을 통한 영역 분류 정밀도 확보 및 확장성 검토.

### [03_02] 영역별 분석 및 매핑 로직
* **[03_02.Analyzer_Core_Logic.md](./03_02.Analyzer_Core_Logic.md)**
    * **핵심 내용:** - `FROM`절 서브쿼리(Fixed) 우선 처리 원칙 및 SQL 노드 순회 알고리즘.
        - `SELECT/WHERE` 노드의 자동 분류 및 데이터 매핑 로직 상세.

### [03_03] 예외 처리 및 물리 파일 운영
* **[03_03.Exception_Handling_and_Logging.md](./03_03.Exception_Handling_and_Logging.md)**
    * **핵심 내용:** - 분석 결과에 따른 파일 자동 이동 프로세스 (`inbox` → `success` / `failed`).
        - 분석 실패 쿼리의 물리적 격리 및 시니어 검토를 위한 에러 로깅 체계.

### [03_04] DB 기반 실행 흐름 (Move-then-Insert)
* **[03_04.Analyzer_Execution_Flow.md](./03_04.Analyzer_Execution_Flow.md)**
    * **핵심 내용:** - 동일 쿼리 재유입 시 **'이동 후 삽입(Move-then-Insert)'** 전략 수행.
        - 기존 데이터를 `History`로 즉시 아카이빙하고 `Current` 테이블을 최신화하는 배치 워크플로우.



## 3. 구현 단계 전환 체크리스트 (Checklist)
- [ ] `sqlglot` 라이브러리 분석 성능 검증 완료
- [ ] 물리적 폴더 구조 (`inbox/success/failed`) 생성 여부
- [ ] DB 테이블 (`Asset/History`) DDL 준비 여부
- [ ] 실무 메타데이터 입력을 위한 인터페이스 정의 여부

---
*최종 업데이트: 2025-12-26*
*작성자: 시니어 시스템 엔지니어 & Query-Bong 팀*
# 📄 03_01.Analyzer_Technology_Stack.md

## 1. 질문 (Question)
**분석의 정확성이 프로젝트의 성패를 결정하는 상황에서, `sqlglot` 기반의 분석 엔진은 어떤 기술적 신뢰성을 제공합니까?**

## 2. 답변 요약 (Answer Summary)
단순 문자열 파싱의 한계를 극복하기 위해 SQL의 문법 구조를 트리(Tree) 형태로 완벽히 재구성하는 **AST 기반 분석**을 채택한다. 이를 통해 복잡하게 얽힌 서브쿼리와 함수의 위치를 100% 정밀도로 식별하며, 설계 원칙(`02_05`)에 따른 영역 분류의 무결성을 보장한다.

## 3. 구현 핵심 기술 상세

### 3.1 AST(Abstract Syntax Tree) 기반 추출
* **신뢰성:** 쿼리의 모든 구성 요소를 객체화하여 관리. (예: `From` 절 내부의 서브쿼리는 독립된 `Table` 객체가 아닌 `Subquery` 객체로 인지하여 `Fixed` 처리 가능)
* **정합성:** 각 노드의 부모/자식 관계를 추적하여, 중첩된 쿼리 내에서도 필드의 소속 영역을 오판하지 않음.

### 3.2 Dialect 정규화 엔진
* **역할:** Oracle, PostgreSQL 등 서로 다른 SQL 문법을 하나의 표준 구조로 통일.
* **이유:** 입력되는 쿼리의 스타일에 관계없이 일관된 JSON 추출 결과 보장.

### 3.3 재귀적 분석 (Recursive Analysis)
* **로직:** 쿼리 내부에 또 다른 쿼리가 존재하는 경우(Subquery), 동일한 분석 알고리즘을 재귀적으로 호출하여 계층적 정밀도 유지.

---
*최종 업데이트: 2025-12-26*
*작성자: Query-Bong 프로젝트 팀*
# 📄 03_02.Analyzer_Core_Logic.md

## 1. 질문 (Question)
**분석기(Analyzer)가 입력된 SQL을 파싱하여 JSON 스펙(`02_03`, `02_04`)에 따라 영역별로 데이터를 분류하는 핵심 로직은 무엇입니까?**

## 2. 답변 요약 (Answer Summary)
`sqlglot`이 생성한 AST(추상 구문 트리)를 기반으로 **'순차적 노드 탐색(Sequential Node Visiting)'** 전략을 사용한다. 쿼리의 각 절(Clause)을 식별한 뒤, 해당 절의 특성과 위치 값에 따라 `Fixed`, `Flexible`, `Change` 객체로 자동 매핑하며, 중첩 쿼리는 재귀 호출을 통해 처리한다.

## 3. 핵심 분석 로직 (Core Processing Logic)

### 3.1 단계별 처리 프로세스
1. **Normalization:** 입력 쿼리의 Alias를 제거하고 테이블명을 Full Name으로 치환한다. (`02_01` 준수)
2. **AST Generation:** `sqlglot.parse_one()`을 통해 쿼리를 트리 구조로 변환한다.
3. **Recursive Visiting:** 트리의 루트(Root)부터 말단 노드까지 아래 규칙에 따라 순회한다.

### 3.2 구문별 자동 분류 매커니즘
| SQL 구문(Node) | 분석기 판단 로직 (Logic) | 타겟 영역 (Target) |
| :--- | :--- | :--- |
| **FROM / JOIN** | 테이블 객체 및 인라인 뷰(서브쿼리) 발견 시 | **Fixed Area** |
| **SELECT (Pure)** | 함수가 없는 단일 컬럼 발견 시 | **Flexible Area** (기본) |
| **SELECT (Func)** | `SUM`, `COUNT` 등 집계 함수 노드 발견 시 | **Flexible Area** (지표) |
| **WHERE** | 비교 연산자(`EQ`, `IN`, `BETWEEN`) 노드 발견 시 | **Change Area** (필터) |
| **GROUP BY** | 그룹핑 대상 컬럼 노드 발견 시 | **Change Area** (그룹) |

### 3.3 유닛(Unit) 등급 분류 로직 (Unit Classification)
* **판단 기준:** 쿼리에 포함된 유효 엔티티(Entity)의 개수.
* **유효 엔티티 산정 방식:**
    * **Driven Table 기준:** `FROM` 절의 Main Table + **INNER JOIN** 된 Table만 카운트.
    * **제외 대상:** `LEFT OUTER`, `RIGHT OUTER` 등 Outer Join 된 테이블은 복잡도 산정에서 제외.
* **등급 분류:**
    * **Unit A (단순):** 유효 엔티티 1개 (Main Table Only).
    * **Unit B (상세):** 유효 엔티티 2개 (Main + 1 Inner Join).
    * **Unit C (복합):** 유효 엔티티 3개 이상 (Main + 2 Inner Joins 이상).

### 3.4 서브쿼리 처리 우선순위 (Priority Rule)
* **Rule #1:** `FROM` 절 내부의 서브쿼리는 내부 구성 요소(SELECT 등)와 관계없이 전체를 하나의 **고정 데이터셋(Fixed)**으로 취급하여 캡슐화한다.
* **Rule #2:** 그 외 영역(SELECT, WHERE)의 서브쿼리는 메인 쿼리의 해당 영역 속성을 상속받아 분해한다.

---
*최종 업데이트: 2025-12-26*
*작성자: Query-Bong 프로젝트 팀*
# 📄 03_03.Exception_Handling_and_Logging.md

## 1. 질문 (Question)
**분석기(Analyzer) 운영 시 작업의 성공/실패 여부에 따른 파일 관리 및 사후 처리 프로세스는 어떻게 구성됩니까?**

## 2. 답변 요약 (Answer Summary)
분석기는 입력된 소스 파일을 처리 결과에 따라 물리적으로 이동시키는 **'상태 기반 디렉토리 운영'** 방식을 채택한다. `Success` 폴더는 자산화된 데이터를, `Failed` 폴더는 로직 보완이 필요한 원본을 담아 운영의 가시성과 디버깅 효율을 극대화한다.

## 3. 물리적 파일 관리 전략 (File Operation Strategy)

### 3.1 디렉토리 구조 및 역할
* **`/source/inbox/`**: 분석 대기 중인 원본 SQL 파일들이 투입되는 장소.
* **`/source/success/`**: 분석이 완벽히 끝나 JSON이 생성된 원본 SQL 보관소.
* **`/source/failed/`**: **[핵심]** 분석 중 에러가 발생하여 엔진 수정이 필요한 원본 SQL 격리소.
* **`/output/json/`**: 성공한 결과물(JSON)이 저장되는 배포소.

### 3.2 프로세스 워크플로우 (Flow)
1.  **Read**: `inbox`에서 파일을 읽어 분석 시작.
2.  **Process**: `sqlglot`을 이용한 AST 분석 및 영역 분류 실행.
3.  **Branch**:
    * **성공 시**: JSON을 `output/json/`에 저장 후, 원본은 `success/`로 이동(Move).
    * **실패 시**: 원본 SQL을 즉시 `failed/`로 이동(Move)하고 에러 리포트 생성.
4.  **Feedback**: 시니어 엔지니어는 `failed/` 폴더의 파일을 확인하여 분석 엔진의 예외 로직을 보완.

---
*최종 업데이트: 2025-12-26*
*작성자: Query-Bong 프로젝트 팀*
# 📄 03_04.Analyzer_Execution_Flow.md

## 1. 질문 (Question)
**분석기(Analyzer)가 동일한 뼈대를 가진 쿼리를 재분석할 때, 최신성 유지와 과거 이력 보존을 처리하는 프로세스는 무엇입니까?**

## 2. 답변 요약 (Answer Summary)
쿼리의 정체성(Identity)을 결정하는 **'SELECT 절과 FROM 절의 조합'**을 기준으로 동일 여부를 판정한다. 동일한 쿼리가 유입될 경우, 기존 레코드는 `History` 테이블로 물리적 이동(Move)시키고, `Current` 테이블에는 최신 분석 결과와 피드백이 반영된 데이터를 새롭게 적재하는 **'Move-then-Insert'** 흐름을 따른다.

## 3. 상세 프로세스 흐름 (Execution Flow)

1. **Extraction & Identity Hash:** `sqlglot` 분석을 통해 JSON을 생성하고, `SELECT` 컬럼과 `FROM` 테이블 정보를 조합해 고유한 `identity_hash`를 생성한다.
2. **Duplicate Check:** `TB_QUERY_ASSET (Current)`에서 동일한 `identity_hash`를 가진 레코드가 있는지 확인한다.
3. **Archiving (The Move):** 동일 내역 발견 시, 기존 레코드를 `TB_QUERY_HISTORY`로 즉시 인서트(Insert)한 후 `Current` 테이블에서 해당 레코드를 삭제(Delete)한다.
4. **New Asset Insert:** 신규 생성된 JSON과 실무 메타데이터(부서, 담당자, 메일 정보 등)를 `TB_QUERY_ASSET`에 최종 적재한다.
5. **Finalize:** 처리된 원본 SQL 파일을 `success/` 폴더로 이동하며 종료한다.

---
*최종 업데이트: 2025-12-26*
*작성자: 시니어 시스템 엔지니어 & Query-Bong 팀*
